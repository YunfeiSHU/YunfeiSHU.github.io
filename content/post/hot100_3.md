+++
date = '2025-09-12T17:50:52+08:00'
draft = false
title = 'Hot100_3'
summary = '6~7，学了单调栈得到局部两较小/较大，对撞指针：同时移动的情况'
tags = ['hot100']
+++

6. 三数之和：

   ![image-20250912112223609](./assets/image-20250912112223609.png)

   - 排序后对撞指针：优化 暴力解法：三重循环`i-j-k`  ---> `i-（j,k）`双重循环：内层对撞指针
     - `sum < 0, j++` ;  `sum>0,k--` ; 
     - 相同则同时移动：`sum==0,j++,k--`，**如果有重复，则多移动：至少移动1**（容易想当然，包含在循环中）
   - 要求：无重复三元组，还需要考虑：去重
     - i 重复,continue ; j,k 满足条件时，append，多次j++/k--直到满足

   ```go
   func threeSum(nums []int) [][]int {
   	res := [][]int{}
   	sort.Ints(nums)
   
   	for i := 0; i < len(nums)-2; i++ {
   		if i > 0 && nums[i] == nums[i-1] {
   			continue
   		}
   		j, k := i+1, len(nums)-1
   		for j < k {
   			sum := nums[i] + nums[j] + nums[k]
   			if sum < 0 {
   				j++
   			} else if sum > 0 {
   				k--
   			} else {
   				res = append(res, []int{nums[i], nums[j], nums[k]})
   				j++
   				k--
   				for j < k && nums[j] == nums[j-1] {
   					j++
   				}
   				for j < k && nums[k] == nums[k+1] {
   					k--
   				}
   
   			}
   		}
   	}
   	return res
   }
   ```

   

7. 接雨水：

   ![image-20250912172006924](./assets/image-20250912172006924.png)

   - 要想得到积水：需要**找到一个柱子的左右两侧最近的较大值**，**且两个柱子的间隔>=1**，才可以有积水	
     - **`r-l-1`为积水的宽度** ------[2,1,2] 积水1格：`2 (/r)-0 (/l)-1`
   - 难点：如何得到局部的两个较大值
     - 单调栈：设计栈顶为min的单调栈，入栈元素为较小值为较小值，可以入栈时：栈顶和入栈元素为两个局部较大值

   ```go
   func trap(height []int) (res int) {
       stack := make([]int, 0)  // 单调栈：存储索引
       for i := 0; i < len(height); i++ {
           for len(stack) > 0 && height[stack[len(stack)-1]] < height[i] {  //栈顶为较小值，才入栈：维护递增栈，得到两个局部较大值
               tmp := stack[len(stack)-1]  // 出栈
               stack = stack[:len(stack)-1]  
               
               //求积水
               if len(stack) > 0 {  
                   l := stack[len(stack)-1]  
                   hei := min(height[l], height[i]) - height[tmp] 
                   res += (i - l - 1) * hei  
               }
           
           }
           stack = append(stack, i)  //入栈
       }
       return res
   }
   ```

   > 发现了自己做遍历时：喜欢过度假设，要活用好反证法，来证明假设不成立

