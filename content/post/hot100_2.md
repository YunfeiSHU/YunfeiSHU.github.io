+++
date = '2025-09-11T16:04:18+08:00'
draft = false
title = 'Hot100_2'
summary = '3~5题'
tags = ['hot100']
+++
3. 最长连续序列：

   ![image-20250911140710910](./assets/image-20250911140710910.png)

   ```go
   func longestConsecutive(nums []int) (res int) {
       hash := make(map[int]bool)
       for _,v := range nums{
           hash[v]=true
       }
       for _,v:= range nums{
           length := 1
           if !hash[v-1] {
               i := v
               for hash[i+1]{
                 length +=1
                 hash[i+1] = false // 没用也可以，优化时间复杂度
                 i +=1  
                
               }
           }
           res = max(length,res)
       }
       return res
   }
   ```

   

4. 移动0：

   ![image-20250911140814194](./assets/image-20250911140814194.png)

   暴力解法：严格保证 0,1交换得到1,0 ，r 之前的都以排序完成

   - 右指针无论遇到0/1都+1，遇到1时与l交换，遇到0不交换
   - 左指针遇到0停止，直到交换后，l + 1，r 之前均满足1,0 ----->遍历 r 层 

   ```go
   func moveZeroes(nums []int) {
   	//暴力解法：
   	for l, r := 0, 0; r < len(nums); r++ {
   		l = 0
   		for nums[r] != 0 && l < len(nums) {
   			if nums[l] == 0 && l < r {
   				nums[l], nums[r] = nums[r], nums[l]
   			}
   			l++
   		}
   	}
   }
   ```

   双指针优化，原理：

   -  **l 只在 r 不为0，交换并移动1；r 无论如何都移动1 -----> 只会在有0时，产生间隔：l != r ，l r 交换后，l之前全1，l~r之前全0**
     - 即 `nums[r] != 0`时 l r 交换，就能保证：r 之前都符合 1,0要求 
       - **无需循环实现：因为新加元素不影响之前 r满足1,0**
     - PS：`if nums[l] == 0` 才交换：没0，则l==r，原地交换，可以忽略这个if

   ```go
   func moveZeroes(nums []int) {
   for l, r := 0, 0; r < len(nums); r++ {
   		if nums[r] != 0 {
   			if nums[l] == 0 {
   				nums[l], nums[r] = nums[r], nums[l]
   			}
   			l++
   		}
   	}
   }
   ```



5. 乘最多水的容器：

   ![image-20250911153627942](./assets/image-20250911153627942.png)

   - 对撞指针：左右开始遍历所有情况
   - 最大值由临界条件（最矮的柱子）决定，更高的柱子无需考虑，下一个情况只可能 <=，不可能出现更大的值，所有只需考虑：较小柱子
     - 指针移动前提：l < r , l++ ; l > r,r--

   - 终止移动：l >= r

   ```go
   func maxArea(nums []int) int{
      var res int
   	for l, r := 0,len(nums)-1; l < r; {
   		h := min(nums[l], nums[r])
   		d := r - l
   		res = max(res, h*d)
   		if nums[l] > nums[r] {
   			r--
   		} else {
   			l++
   		}
   	}
   	return res
   }
   ```

   

